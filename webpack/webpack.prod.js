const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const path = require('path');
const commonVariables = require('./commonVariables');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const TerserPlugin = require('terser-webpack-plugin');
const { InjectManifest } = require('workbox-webpack-plugin');
const WebpackPwaManifest = require('webpack-pwa-manifest');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const PUBLIC_PATH = 'https://food-delivery-7d366.firebaseapp.com/';
module.exports = Object.keys(commonVariables.languages).map(function(language) {
	return {
		mode: 'production',
		/**
		 *  good choice because only a comment is generated into the JS bundle.
		 *  If your users do not open the browser’s devtools, they do not load
		 *  the corresponding source map file generated by webpack.
		 */
		devtool: 'source-map',
		entry: {
			app: [`${commonVariables.appEntry}/index.tsx`]
		},
		/**
		 * we should create files with content hash to output those with contentHash , it's unique and when a file change
		 * we figure out  , if we change file , the hash generated new , there are three type , hash , chunkHash , contentHash
		 * [hash] – if at least one chunk changes, a new hash value for the whole build is generated
		   [chunkhash] – for every changing chunk, a new hash value is generated
		   [contenthash] – for every changed asset, a new hash based on the asset’s content is generated
		 */
		output: {
			filename: 'main.js',
			chunkFilename: `static/js/[name].[contenthash].js`,
			publicPath: '/',
			path: `${commonVariables.outputPath}`
		},
		module: {
			rules: [
				{
					test: /\.(js|ts)x?$/,
					exclude: /node_modules/,
					resolve: {
						extensions: ['.js', 'jsx', '.tsx', '.ts']
					},
					use: [
						{ loader: 'babel-loader' }
					]
				},
				{
					test: /\.(sa|sc|c)ss$/,
					use: [
						{
							loader: MiniCssExtractPlugin.loader
						},
						{
							loader: 'css-loader',
							options: {
								sourceMap: false
							}
						},
						{
							loader: 'postcss-loader',
							options: {
								sourceMap: false,
								postcssOptions: {
									config: path.resolve(__dirname, '../postcss.config.js')
								}

							}
						},
						{
							loader: 'sass-loader',
							options: {
								sourceMap: false
							}
						}
					]
				},
				{
					test: /\.(png|jpg|woff|woff2|eot|ttf|jpe?g|gif)$/,
					loader: 'url-loader',
					options: {
						name: 'static/images/[name].[ext]'
					}
				},
				{
					test: /\.svg$/,
					use: [
						{
							loader: 'babel-loader'
						},
						{
							loader: 'react-svg-loader',
							options: {
								jsx: true
							}
						}
					]
				}
			]
		},
		/**
		 * When we want to use cdn and we can exclude react and react dom from project build
		 */
		// externals: {
		// 	react: 'React',
		// 	'react-dom': 'ReactDom'
		// },
		/**
		 * this is for set threshold for size of bundle in the css and js file we set max size 100 for it
		 * without this , it may we get warning but with this we get error , for avoid to push in the VC
		 */
		// performance: {
		// 	hints: 'error',
		// 	maxAssetSize: 100 * 1024, // 100 KiB
		// 	maxEntrypointSize: 100 * 1024 // 100 KiB
		// },
		optimization: {
			/**
			 * for choose module id
			 * this is deprecated in the webpack 5
			 */
			moduleIds: 'hashed',
			// 	What does this even mean? Every application or site built with webpack includes a runtime and manifest.
			// 	It’s the boilerplate code that does the magic. The manifest wires together our code and the vendor code.
			// 	It is not especially large, but it is duplicated for every entry point unless you do something about it.
			// Once again, if you want to optimize browser caching, then it might be useful to extract the manifest into
			// a separate bundle. This saves your users from unnecessarily re-downloading files. However
			runtimeChunk: {
				name: 'manifest'
			},
			/**
			 * For tree shaking and minimize , I think it's true default
			 */
			minimize: true,
			minimizer: [
				new TerserPlugin({
					// enable parallel running
					parallel: true
				}),
				new CssMinimizerPlugin({
					minimizerOptions: {
						// to delete comment in the css file
						preset: [
							'default',
							{
								discardComments: { removeAll: true }
							}
						]
					}
				})],
			splitChunks: {
				cacheGroups: {
					// styles: {
					// 	name: 'styles',
					// 	test: /\.css$/,
					// 	chunks: 'all',
					// 	enforce: true,
					// },
					/**
					 * this is good for split chunk file base same imported module
					 */
					node_vendors: {
						chunks: 'all',
						priority: 1
					}
				}
			}
		},
		plugins: [
			// new BundleAnalyzerPlugin(),
			new MiniCssExtractPlugin({
				filename: `static/css/[name].[contenthash].css`,
				chunkFilename: `static/css/[id].[contenthash].css`
			}),
			new HtmlWebpackPlugin({
				meta: {
					viewport: 'width=device-width, initial-scale=1,viewport-fit=cover, shrink-to-fit=no',
					'theme-color': '#FF7714',
					'apple-mobile-web-app-status-bar-style': '#FF7714',
					'og:title': 'Food Delivery',
					'og:description': 'A simple Boilerplate of React Js',
					'content-type': { 'http-equiv': 'content-type', content: 'text/html; charset=UTF-8' }
				},
				title: 'Food Delivery',
				template: 'assets/index.html',
				minify: {
					collapseWhitespace: true,
					removeComments: true,
					removeRedundantAttributes: true,
					removeScriptTypeAttributes: true,
					removeStyleLinkTypeAttributes: true,
					useShortDoctype: true
				}
			}),
			new InjectManifest({
				swSrc: path.resolve(process.cwd(), './src/sw.ts'),
				swDest: 'service-worker.js',
				mode: 'production'
			}),
			new WebpackPwaManifest({
				name: 'Food Delivery',
				short_name: 'Food Delivery',
				filename: 'manifest.json',
				description: 'Food Delivery React App',
				start_url: '.',
				display: 'standalone',
				orientation: 'portrait',
				background_color: '#f0f2f5',
				theme_color: '#FF7714',
				icons: [
					{
						src: path.resolve('assets/react.png'),
						sizes: [96, 128, 192, 256, 384, 512]
					},
					{
						src: path.resolve('assets/static/maskable.png'),
						sizes: '128x128',
						purpose: 'maskable'
					}
				]
			})
		]
	};
});
